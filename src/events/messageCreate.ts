import { Message } from 'discord.js';
import { DiscordBot } from '../index';
import { LevelService } from '../services/levels/LevelService';
import { logger } from '../utils/logger';
import { AutoModService } from '../services/moderation/AutoModService';
import fs from 'fs';
import path from 'path';
import { DateTime } from 'luxon';
import { updateBattlePassProgress } from '../services/battlepass/updateBattlePassProgress';

function rotateTasks(tasks: any[], max: number, dayOffset: number): any[] {
    if (tasks.length === 0) return [];
    const offset = (dayOffset * max) % tasks.length;
    let rotated = [];
    for (let i = 0; i < max && tasks.length > 0; i++) {
      rotated.push(tasks[(offset + i) % tasks.length]);
    }
    return rotated;
}

export default async function messageCreate(bot: DiscordBot, message: Message): Promise<void> {
    if (message.author.bot || !message.guild || !message.channel.isTextBased()) return;

    try {
        const settings = await bot.settingsService.getGuildSettings(message.guild.id);

        await updateBattlePassProgress({
            bot,
            userId: message.author.id,
            guildId: message.guild.id,
            type: 'messages',
            amount: 1,
            isDaily: true,
            channel: message.channel,
            messageContent: message.content
        });

        const blocked = await bot.autoMod.enforce(message);
        if (blocked) return;

        if (message.attachments.size > 0) {
            await saveImagesFromMessage(message, bot);
        }
        await saveGifsFromEmbedsAndContent(message, bot);

        const contentLength = message.content?.length ?? 0;
        const memberRoleIds = message.member?.roles.cache.map(r => r.id) ?? [];
        await bot.database.createUser(message.author.id, message.author.username);

        const levelResult = await bot.levelService.addMessageXP(
            message.author.id,
            message.guild.id,
            message.channel.id,
            contentLength,
            memberRoleIds
        );
        
        if (levelResult.levelUp && settings.levels.levelup_messages) {
            const congrats = [
              `üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é, ${message.author}! –í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ ${levelResult.newLevel} —É—Ä–æ–≤–Ω—è!`,
              `‚≠ê –ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ! ${message.author} —Ç–µ–ø–µ—Ä—å ${levelResult.newLevel} —É—Ä–æ–≤–Ω—è!`,
              `üèÜ ${message.author} –ø–æ–≤—ã—Å–∏–ª—Å—è –¥–æ ${levelResult.newLevel} —É—Ä–æ–≤–Ω—è! –¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!`,
              `üéä –£—Ä–∞! ${message.author} –¥–æ—Å—Ç–∏–≥ ${levelResult.newLevel} —É—Ä–æ–≤–Ω—è!`
            ];
            const text = `${congrats[Math.floor(Math.random() * congrats.length)]}\nüí∞ –ü–æ–ª—É—á–µ–Ω–æ: ${levelResult.coinsEarned} –º–æ–Ω–µ—Ç!`;
          
            const targetChannelId = settings.levels.levelup_channel || message.channel.id; // levels.levelup_channel –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–µ–Ω
            const target = await message.client.channels.fetch(targetChannelId).catch(() => null);
          
            if (target && 'isSendable' in target && target.isSendable()) {
              await target.send({ content: text });
            } else {
              await message.reply({ content: text });
            }
        }

        const prefix = '/';

        if (message.content.length > 2 && !message.content.startsWith(prefix)) {
            if (!containsInappropriateContent(message.content)) {
                await bot.markov.trainFromMessage(
                    message.guild.id,
                    message.channel.id,
                    message.content
                );
            }
        }

        const responseChance = settings.ai.response_chance || 0.45;

        if (Math.random() < responseChance && message.content.length > 5) {            
            logger.debug('Attempting to generate AI response...');

            const response = await bot.markov.generateResponse(
                message.guild.id,
                message.channel.id
            );

            logger.debug(`Generated response: ${response}`);

            if (response && response.length > 3) {
                try {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–∞–Ω–∞–ª –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç sendTyping
                    if ('sendTyping' in message.channel) {
                        await message.channel.sendTyping();
                    }
                    
                    const delay = Math.min(response.length * 50, 3000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    
                    if (message.channel.isSendable()) {
                        await bot.markov.sendAIReply(message, response);
                    }
                } catch (error) {
                    logger.error('Error sending Markov response:', error);
                }
            }
        }

    } catch (error) {
        logger.error('Error in messageCreate event:', error);
    }
}

async function saveImagesFromMessage(message: Message, bot: DiscordBot) {
    try {
        // –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É, –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
        const imagesDir = './mem_images';
        if (!fs.existsSync(imagesDir)) {
            fs.mkdirSync(imagesDir, { recursive: true });
        }

        for (const [, attachment] of message.attachments) {
            const name = attachment.name?.toLowerCase() || '';
            const isImage = (attachment.contentType?.startsWith('image/') ?? false)
              || name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.png') || name.endsWith('.webp');
            const isGif = (attachment.contentType === 'image/gif')
              || name.endsWith('.gif');
              
            if (!isImage && !isGif) continue;

            // –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ (gif/jpeg/png/...)
            const ext =
                path.extname(attachment.name ?? (isGif ? '.gif' : '.png'));
            const fileName = `${message.id}_${attachment.id}${ext}`;
            const filePath = path.join(imagesDir, fileName);

            try {
                // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª (–∏ –≥–∏—Ñ–∫–∏, –∏ –∫–∞—Ä—Ç–∏–Ω–∫–∏)
                const response = await fetch(attachment.url);
                const buffer = Buffer.from(await response.arrayBuffer());
                fs.writeFileSync(filePath, buffer);

                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –≤ –ë–î (–º–æ–∂–µ—à—å –¥–æ–±–∞–≤–∏—Ç—å —Ç–∏–ø –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
                await bot.database.saveMemeImage({
                    guildId: message.guild!.id,
                    channelId: message.channel.id,
                    messageId: message.id,
                    userId: message.author.id,
                    filePath: filePath,
                    originalUrl: attachment.url,
                    // isGif: isGif // –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                });

                logger.debug(`Saved meme file: ${fileName}`);
            } catch (error) {
                logger.error(`Failed to save file ${attachment.name}:`, error);
            }
        }
    } catch (error) {
        logger.error('Error in saveImagesFromMessage:', error);
    }
}

async function saveGifsFromEmbedsAndContent(message: Message, bot: DiscordBot) {
    try {
        // 1. From embeds (GIPHY, TENOR, etc.)
        for (const embed of message.embeds) {
            let gifUrl: string | undefined = undefined;
            if (embed.url && embed.url.endsWith('.gif')) gifUrl = embed.url;
            else if (embed.image?.url && embed.image.url.endsWith('.gif')) gifUrl = embed.image.url;
            else if (embed.thumbnail?.url && embed.thumbnail.url.endsWith('.gif')) gifUrl = embed.thumbnail.url;

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¢–û–õ–¨–ö–û –ø—Ä—è–º—É—é .gif —Å—Å—ã–ª–∫—É!
            if (gifUrl) {
                await bot.database.saveMemeImage({
                    guildId: message.guild!.id,
                    channelId: message.channel.id,
                    messageId: message.id,
                    userId: message.author.id,
                    filePath: '', // –ª–∏–±–æ –Ω–µ –ø–∏—à–∏, –ª–∏–±–æ special-type
                    originalUrl: gifUrl
                });
                logger.debug(`[GIF EMBED] Saved original url: ${gifUrl}`);
            }
        }
        // 2. From —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å—Å—ã–ª–æ–∫ .gif –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏
        const possibleGifUrls = message.content.match(/https?:\/\/\S+\.gif/g);
        if (possibleGifUrls) {
            for (const url of possibleGifUrls) {
                await bot.database.saveMemeImage({
                    guildId: message.guild!.id,
                    channelId: message.channel.id,
                    messageId: message.id,
                    userId: message.author.id,
                    filePath: '', // –ª–∏–±–æ –Ω–µ –ø–∏—à–∏, –ª–∏–±–æ special-type
                    originalUrl: url
                });
                logger.debug(`[GIF TEXT] Saved original url: ${url}`);
            }
        }
    } catch (error) {
        logger.error('Error in saveGifsFromEmbedsAndContent:', error);
    }
}

function containsInappropriateContent(content: string): boolean {
    const inappropriatePatterns = [
        /@(everyone|here)/i,
        /https?:\/\//i, // URL
        /<@[!&]?\d+>/i, // –£–ø–æ–º–∏–Ω–∞–Ω–∏—è
        /```/, // –ö–æ–¥-–±–ª–æ–∫–∏
        /^\s*$/, // –ü—É—Å—Ç—ã–µ –∏–ª–∏ –ø—Ä–æ–±–µ–ª—å–Ω—ã–µ
    ];

    return inappropriatePatterns.some(pattern => pattern.test(content));
}