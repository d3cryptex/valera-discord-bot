"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.data = void 0;
exports.execute = execute;
const discord_js_1 = require("discord.js");
const logger_1 = require("../../utils/logger");
const SettingsService_1 = require("../../services/settings/SettingsService");
exports.data = new discord_js_1.SlashCommandBuilder()
    .setName('markov')
    .setDescription('–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ AI-—á–∞—Ç–æ–º (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)')
    .setDefaultMemberPermissions(discord_js_1.PermissionFlagsBits.Administrator)
    .addSubcommand(subcommand => subcommand
    .setName('generate')
    .setDescription('–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç')
    .addStringOption(option => option
    .setName('start_word')
    .setDescription('–°—Ç–∞—Ä—Ç–æ–≤–æ–µ —Å–ª–æ–≤–æ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)')))
    .addSubcommand(subcommand => subcommand
    .setName('stats')
    .setDescription('–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–±—É—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏'))
    .addSubcommand(subcommand => subcommand
    .setName('clear')
    .setDescription('–û—á–∏—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ–±—É—á–µ–Ω–∏—è (–û–°–¢–û–†–û–ñ–ù–û!)'))
    .addSubcommand(subcommand => subcommand
    .setName('meme')
    .setDescription('–°–æ–∑–¥–∞—Ç—å –º–µ–º –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ AI-—Ç–µ–∫—Å—Ç–∞'));
async function execute(interaction, bot) {
    const settingsService = new SettingsService_1.SettingsService(bot.database, bot.redis);
    const settings = await settingsService.getGuildSettings(interaction.guild.id);
    if (!settings.economy.shop_enabled) {
        const embed = new discord_js_1.EmbedBuilder()
            .setColor('#eb4034')
            .setTitle('–û—à–∏–±–∫–∞')
            .setDescription('‚ùå –ò–ò –≤—ã–∫–ª—é—á–µ–Ω –Ω–∞ —ç—Ç–æ–º —Å–µ—Ä–≤–µ—Ä–µ.');
        await interaction.editReply({ embeds: [embed] });
        return;
    }
    const subcommand = interaction.options.getSubcommand();
    switch (subcommand) {
        case 'generate':
            await handleGenerate(interaction, bot);
            break;
        case 'stats':
            await handleStats(interaction, bot);
            break;
        case 'clear':
            await handleClear(interaction, bot);
            break;
        case 'meme':
            await handleMeme(interaction, bot);
            break;
    }
}
async function handleMeme(interaction, bot) {
    await interaction.deferReply();
    try {
        if (!interaction.guildId) {
            await interaction.editReply({ content: '–ú–µ–º—ã —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–∞—Ö!' });
            return;
        }
        // 1-3 –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Å–ª—É—á–∞–π–Ω–æ, –º–æ–∂–Ω–æ option –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ —Å—Ç—Ä–æ–≥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        const count = Math.floor(Math.random() * 3) + 1;
        const imagePaths = await bot.database.getRandomMemeImages(interaction.guildId, count);
        if (!imagePaths.length) {
            const embed = new discord_js_1.EmbedBuilder()
                .setColor('#eb4034')
                .setTitle('–û—à–∏–±–∫–∞')
                .setDescription('‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –∫–∞—Ä—Ç–∏–Ω–æ–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ!');
            await interaction.editReply({ embeds: [embed] });
            return;
        }
        const topText = (await bot.markov.generateResponse(interaction.guildId, interaction.channelId)) || '';
        const bottomText = (await bot.markov.generateResponse(interaction.guildId, interaction.channelId)) || '';
        let buffer;
        if (imagePaths.length === 1) {
            // –û–±—ã—á–Ω—ã–π –º–µ–º: –æ–¥–Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞ ‚Äî —Ç–µ–∫—Å—Ç —Å–≤–µ—Ä—Ö—É/—Å–Ω–∏–∑—É
            buffer = await bot.markov.makeMultiImageMeme(imagePaths, topText, bottomText);
        }
        else {
            // –û–≤–µ—Ä–ª–µ–π: main ‚Äî –ø–µ—Ä–≤–∞—è, overlays ‚Äî –æ—Å—Ç–∞–ª—å–Ω—ã–µ
            const [mainPath, ...overlays] = imagePaths;
            buffer = await bot.markov.makeOverlayMeme(mainPath, overlays, topText, bottomText);
        }
        const attachment = new discord_js_1.AttachmentBuilder(buffer, { name: 'ai_meme.png' });
        await interaction.editReply({
            files: [attachment]
        });
    }
    catch (error) {
        logger_1.logger.error('Error generating AI meme:', error);
        const embed = new discord_js_1.EmbedBuilder()
            .setColor('#eb4034')
            .setTitle('–û—à–∏–±–∫–∞')
            .setDescription('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–µ–º–∞.');
        await interaction.editReply({ embeds: [embed] });
    }
}
async function handleGenerate(interaction, bot) {
    await interaction.deferReply();
    try {
        const response = await bot.markov.generateResponse(interaction.guild.id, interaction.channel.id);
        if (response) {
            const embed = new discord_js_1.EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('ü§ñ AI –û—Ç–≤–µ—Ç')
                .setDescription(response)
                .setFooter({ text: '–°–ª—É—á–∞–π–Ω–æ–µ —Å—Ç–∞—Ä—Ç–æ–≤–æ–µ —Å–ª–æ–≤–æ (bigram)' });
            await interaction.editReply({ embeds: [embed] });
        }
        else {
            const embed = new discord_js_1.EmbedBuilder()
                .setColor('#eb4034')
                .setTitle('–û—à–∏–±–∫–∞')
                .setDescription('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç. –í–æ–∑–º–æ–∂–Ω–æ, –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è.');
            await interaction.editReply({ embeds: [embed] });
            return;
        }
    }
    catch (error) {
        logger_1.logger.error('Error generating Markov response:', error);
        const embed = new discord_js_1.EmbedBuilder()
            .setColor('#eb4034')
            .setTitle('–û—à–∏–±–∫–∞')
            .setDescription('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞.');
        await interaction.editReply({ embeds: [embed] });
        return;
    }
}
async function handleStats(interaction, bot) {
    await interaction.deferReply();
    try {
        if (!bot.database.MarkovBigram)
            throw new Error('Database not connected');
        // –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä
        const totalPairs = await bot.database.MarkovBigram.count({
            where: { guild_id: interaction.guild.id }
        });
        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–ª–æ–≤
        const uniqueTokens = await bot.database.MarkovBigram.count({
            where: { guild_id: interaction.guild.id },
            distinct: true,
            col: 'curr_token'
        });
        const settings = await bot.settingsService.getGuildSettings(interaction.guild.id);
        const embed = new discord_js_1.EmbedBuilder()
            .setColor('#0099FF')
            .setTitle('üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ AI-–º–æ–¥–µ–ª–∏ (Bigram)')
            .addFields([
            { name: '–í—Å–µ–≥–æ –ø–∞—Ä –±–∏–≥—Ä–∞–º–º:', value: totalPairs.toString(), inline: true },
            { name: '–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤:', value: uniqueTokens.toString(), inline: true },
            { name: '–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–∞:', value: `${(settings.ai.response_chance * 100)}%`, inline: true }
        ])
            .setFooter({ text: '–ú–æ–¥–µ–ª—å –æ–±—É—á–∞–µ—Ç—Å—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (Bigram chain)' });
        await interaction.editReply({ embeds: [embed] });
    }
    catch (error) {
        logger_1.logger.error('Error getting Markov stats:', error);
        const embed = new discord_js_1.EmbedBuilder()
            .setColor('#eb4034')
            .setTitle('–û—à–∏–±–∫–∞')
            .setDescription('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.');
        await interaction.editReply({ embeds: [embed] });
        return;
    }
}
async function handleClear(interaction, bot) {
    await interaction.deferReply();
    try {
        if (!bot.database.MarkovBigram) {
            throw new Error('Database not connected');
        }
        // –£–¥–∞–ª—è–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞
        await bot.database.MarkovBigram.destroy({
            where: { guild_id: interaction.guild.id }
        });
        const embed = new discord_js_1.EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('üóëÔ∏è –î–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã')
            .setDescription('–í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±—É—á–µ–Ω–∏—è AI-–º–æ–¥–µ–ª–∏ –¥–ª—è —ç—Ç–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã.')
            .setFooter({ text: '–ú–æ–¥–µ–ª—å –Ω–∞—á–Ω–µ—Ç –æ–±—É—á–µ–Ω–∏–µ –∑–∞–Ω–æ–≤–æ —Å –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π' });
        await interaction.editReply({ embeds: [embed] });
    }
    catch (error) {
        logger_1.logger.error('Error clearing Markov data:', error);
        const embed = new discord_js_1.EmbedBuilder()
            .setColor('#eb4034')
            .setTitle('–û—à–∏–±–∫–∞')
            .setDescription('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö.');
        await interaction.editReply({ embeds: [embed] });
        return;
    }
}
//# sourceMappingURL=markov.js.map